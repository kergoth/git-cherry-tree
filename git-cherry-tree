#!/usr/bin/env python
"""
git-cherry-tree [OPTIONS] DESTBRANCH [SRCBRANCH] [LIMIT] [-- PATH...]

Same as `git-cherry`, but consider only patches touching given subdirs.
Has also extra features for interactive picking of a patch sequence.

Example:
  Which patches are in current branch, but not in 0.8.x
  $ git cherry-tree 0.8.x

"""
# Author: Pauli Virtanen <pav@iki.fi>. This script is in the public domain.

from subprocess import Popen, PIPE, call
import optparse
import re
import os

def main():
    p = optparse.OptionParser(__doc__.strip())
    p.add_option("-m", "--no-missing-only", action="store_false",
                 dest="missing_only", default=True,
                 help="don't show only missing patches")
    p.add_option("-e", "--no-pretty", action="store_false", 
                 dest="pretty", default=True,
                 help="don't show pretty log for each patch")
    p.add_option("-o", "--no-orly", action="store_false", 
                 dest="orly", default=True,
                 help="don't check if patch has already been applied in working tree")
    p.add_option("--stat", action="store_true",
                 help="show patch statistics")
    p.add_option("-p", "--pick", action="store_false",
                 help="cherry-pick all missing patches")
    p.add_option("-x", "--mark-picked", action="store_true",
                 help="if pick: mark changeset as picked (see cherry-pick)")
    p.add_option("-s", "--signoff", action="store_true",
                 help="if pick: signoff picked changesets (see cherry-pick)")
    p.add_option("-n", "--no-commit", action="store_true",
                 help="if pick: don't commit (see cherry-pick)")
    p.add_option("-i", "--interactive", action="store_true",
                 help="if pick: ask before picking each patch")
    options, args = p.parse_args()

    paths = p.rargs
    cherry_args = p.largs

    if not paths:
        # default to root directory
        paths = [git('rev-parse', '--show-cdup').strip()]
        if paths == ['']:
            paths = ['.']

    if not paths or not cherry_args:
        p.error('too few arguments')

    pick_args = []
    if options.mark_picked:
        pick_args.append('-x')
    if options.signoff:
        pick_args.append('-s')
    if options.no_commit:
        pick_args.append('-n')

    out = git('cherry', *cherry_args)
    commits = [x.split(None, 1) for x in out.split("\n") if x.strip()]
    prefix = git('rev-parse', '--show-prefix').strip()

    def path_to_re(pth):
        pth = os.path.normpath(os.path.join(prefix, pth))
        if pth == '.':
            pth = ''
        pth = pth.replace('.', r'\.')
        return pth + '.*'
    paths_re = re.compile('|'.join(map(path_to_re, paths)))

    to_pick = []

    def format_patch(patch, max_len=80):
        if options.pretty:
            out = git('show', '--abbrev-commit', '--quiet', '--pretty=oneline',
                      patch).strip()[:max_len]
        else:
            out = patch

        if options.stat:
            stat = git('show', '--pretty=oneline', '--stat', patch).strip()
            stat = "\n".join(stat.split("\n")[1:-1]).rstrip()
            stat = "\n           " + stat.replace("\n", "\n           ")
            out += stat

        return out
    
    for act, patch in commits:
        out = git('diff-tree', '--name-only', '-r', patch)
        paths = [x for x in out.split("\n") if x.strip()][1:]
        ok = False
        for p in paths:
            if paths_re.match(p):
                ok = True
                break
        if not ok:
            continue

        if options.orly and act == '+':
            if is_patch_already_applied(patch):
                act = '-'

        if options.missing_only:
            if act == '+':
                print format_patch(patch)
        else:
            print "%s %s" % (act, format_patch(patch, 78))

        if act == '+':
            to_pick.append(patch)

    if options.pick:
        do_cherry_pick(to_pick, pick_args, interactive=options.interactive)

def is_patch_already_applied(patch):
    patch = git('format-patch', '--stdout', patch + '^!')
    cwd = os.getcwd()
    env = dict(os.environ)
    env['LC_ALL'] = 'C'
    try:
        dirname = git('rev-parse', '--show-cdup').strip()
        if dirname:
            os.chdir(dirname)
        p = Popen(['patch', '-p1', '-N', '--dry-run'], stdout=PIPE, stderr=PIPE,
                  stdin=PIPE, env=env)
        out, err = p.communicate(patch)
        out += err
        if 'Reversed (or previously applied) patch detected' in out \
               and not 'Hunk' in out:
            return True
    finally:
        os.chdir(cwd)
    return False

def do_cherry_pick(to_pick, pick_args, interactive=False):
    for patch in to_pick:
        info = git('show', '--abbrev-commit', '--quiet', '--pretty=oneline',
                   patch)
        print "\n\n-- Cherry-picking " + "-"*50
        print info

        if interactive:
            ok = True
            while True:
                ip = raw_input("[a]pply patch, [s]kip patch: ").strip()
                if ip == 'a':
                    break
                elif ip == 's':
                    ok = False
                    break
            if not ok:
                continue

        out, ret = git(*(['cherry-pick'] + pick_args + [patch]),
                       returncode=True)

        if ret != 0:
            if 'nothing added to commit but untracked files present' in out:
                # false alarm... it's just already rebased
                print "Has already been picked"
                continue

            print out
            shell_seen = False
            while True:
                if not shell_seen:
                    ip = raw_input("[s]kip patch, [d]rop to shell: ").strip()
                else:
                    ip = raw_input("[c]ontinue, [d]rop to shell: ").strip()
                if (ip == 's' and not shell_seen) or (ip == 'c' and shell_seen):
                    break
                elif ip == 'd':
                    call(os.environ.get('SHELL', 'bash'))
                    shell_seen = True
            git('co', '-f')

def git(*args, **kw):
    input = kw.pop('input', None)
    returncode = kw.pop('returncode', False)
    if kw:
        raise ValueError('Unknown keyword arguments %s' % kw.keys())
    p = Popen(['git'] + list(args), stdout=PIPE)
    out, err = p.communicate(input=input)
    if not returncode:
        return out
    else:
        return out, p.returncode

if __name__ == "__main__":
    main()
